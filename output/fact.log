# After Instruction Selection:
# Machine code for function fact: SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%vreg5<def> = COPY %A0; CPURegs:%vreg5
	%vreg7<def> = SLTi %vreg5, 1; CPURegs:%vreg7,%vreg5
	%vreg6<def> = ADDiu %ZERO, 1; CPURegs:%vreg6
	BNE %vreg7<kill>, %ZERO, <BB#2>, %AT<imp-def,dead>; CPURegs:%vreg7
	B <BB#1>, %AT<imp-def,dead>
    Successors according to CFG: BB#1(20) BB#2(12)

BB#1: derived from LLVM BB %for.body
    Predecessors according to CFG: BB#0 BB#1
	%vreg0<def> = PHI %vreg5, <BB#0>, %vreg3, <BB#1>; CPURegs:%vreg0,%vreg5,%vreg3
	%vreg1<def> = PHI %vreg6, <BB#0>, %vreg2, <BB#1>; CPURegs:%vreg1,%vreg6,%vreg2
	%vreg2<def> = MUL %vreg0, %vreg1; CPURegs:%vreg2,%vreg0,%vreg1
	%vreg3<def> = ADDiu %vreg0, -1; CPURegs:%vreg3,%vreg0
	BGTZ %vreg3, <BB#1>, %AT<imp-def,dead>; CPURegs:%vreg3
	B <BB#2>, %AT<imp-def,dead>
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Predecessors according to CFG: BB#0 BB#1
	%vreg4<def> = PHI %vreg6, <BB#0>, %vreg2, <BB#1>; CPURegs:%vreg4,%vreg6,%vreg2
	%V0<def> = COPY %vreg4; CPURegs:%vreg4
	RetRA %V0<imp-use>

# End machine code for function fact.

# After ExpandISelPseudos:
# Machine code for function fact: SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%vreg5<def> = COPY %A0; CPURegs:%vreg5
	%vreg7<def> = SLTi %vreg5, 1; CPURegs:%vreg7,%vreg5
	%vreg6<def> = ADDiu %ZERO, 1; CPURegs:%vreg6
	BNE %vreg7<kill>, %ZERO, <BB#2>, %AT<imp-def,dead>; CPURegs:%vreg7
	B <BB#1>, %AT<imp-def,dead>
    Successors according to CFG: BB#1(20) BB#2(12)

BB#1: derived from LLVM BB %for.body
    Predecessors according to CFG: BB#0 BB#1
	%vreg0<def> = PHI %vreg5, <BB#0>, %vreg3, <BB#1>; CPURegs:%vreg0,%vreg5,%vreg3
	%vreg1<def> = PHI %vreg6, <BB#0>, %vreg2, <BB#1>; CPURegs:%vreg1,%vreg6,%vreg2
	%vreg2<def> = MUL %vreg0, %vreg1; CPURegs:%vreg2,%vreg0,%vreg1
	%vreg3<def> = ADDiu %vreg0, -1; CPURegs:%vreg3,%vreg0
	BGTZ %vreg3, <BB#1>, %AT<imp-def,dead>; CPURegs:%vreg3
	B <BB#2>, %AT<imp-def,dead>
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Predecessors according to CFG: BB#0 BB#1
	%vreg4<def> = PHI %vreg6, <BB#0>, %vreg2, <BB#1>; CPURegs:%vreg4,%vreg6,%vreg2
	%V0<def> = COPY %vreg4; CPURegs:%vreg4
	RetRA %V0<imp-use>

# End machine code for function fact.

# After Pre-RegAlloc TailDuplicate:
# Machine code for function fact: SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%vreg5<def> = COPY %A0; CPURegs:%vreg5
	%vreg7<def> = SLTi %vreg5, 1; CPURegs:%vreg7,%vreg5
	%vreg6<def> = ADDiu %ZERO, 1; CPURegs:%vreg6
	BNE %vreg7<kill>, %ZERO, <BB#2>, %AT<imp-def,dead>; CPURegs:%vreg7
	B <BB#1>, %AT<imp-def,dead>
    Successors according to CFG: BB#1(20) BB#2(12)

BB#1: derived from LLVM BB %for.body
    Predecessors according to CFG: BB#0 BB#1
	%vreg0<def> = PHI %vreg5, <BB#0>, %vreg3, <BB#1>; CPURegs:%vreg0,%vreg5,%vreg3
	%vreg1<def> = PHI %vreg6, <BB#0>, %vreg2, <BB#1>; CPURegs:%vreg1,%vreg6,%vreg2
	%vreg2<def> = MUL %vreg0, %vreg1; CPURegs:%vreg2,%vreg0,%vreg1
	%vreg3<def> = ADDiu %vreg0, -1; CPURegs:%vreg3,%vreg0
	BGTZ %vreg3, <BB#1>, %AT<imp-def,dead>; CPURegs:%vreg3
	B <BB#2>, %AT<imp-def,dead>
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Predecessors according to CFG: BB#0 BB#1
	%vreg4<def> = PHI %vreg6, <BB#0>, %vreg2, <BB#1>; CPURegs:%vreg4,%vreg6,%vreg2
	%V0<def> = COPY %vreg4; CPURegs:%vreg4
	RetRA %V0<imp-use>

# End machine code for function fact.

# After codegen DCE pass:
# Machine code for function fact: SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%vreg5<def> = COPY %A0; CPURegs:%vreg5
	%vreg7<def> = SLTi %vreg5, 1; CPURegs:%vreg7,%vreg5
	%vreg6<def> = ADDiu %ZERO, 1; CPURegs:%vreg6
	BNE %vreg7<kill>, %ZERO, <BB#2>, %AT<imp-def,dead>; CPURegs:%vreg7
	B <BB#1>, %AT<imp-def,dead>
    Successors according to CFG: BB#1(20) BB#2(12)

BB#1: derived from LLVM BB %for.body
    Predecessors according to CFG: BB#0 BB#1
	%vreg0<def> = PHI %vreg5, <BB#0>, %vreg3, <BB#1>; CPURegs:%vreg0,%vreg5,%vreg3
	%vreg1<def> = PHI %vreg6, <BB#0>, %vreg2, <BB#1>; CPURegs:%vreg1,%vreg6,%vreg2
	%vreg2<def> = MUL %vreg0, %vreg1; CPURegs:%vreg2,%vreg0,%vreg1
	%vreg3<def> = ADDiu %vreg0, -1; CPURegs:%vreg3,%vreg0
	BGTZ %vreg3, <BB#1>, %AT<imp-def,dead>; CPURegs:%vreg3
	B <BB#2>, %AT<imp-def,dead>
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Predecessors according to CFG: BB#0 BB#1
	%vreg4<def> = PHI %vreg6, <BB#0>, %vreg2, <BB#1>; CPURegs:%vreg4,%vreg6,%vreg2
	%V0<def> = COPY %vreg4; CPURegs:%vreg4
	RetRA %V0<imp-use>

# End machine code for function fact.

# After Machine LICM, CSE and Sinking passes:
# Machine code for function fact: SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%vreg5<def> = COPY %A0; CPURegs:%vreg5
	%vreg7<def> = SLTi %vreg5, 1; CPURegs:%vreg7,%vreg5
	%vreg6<def> = ADDiu %ZERO, 1; CPURegs:%vreg6
	BNE %vreg7, %ZERO, <BB#2>, %AT<imp-def>; CPURegs:%vreg7
    Successors according to CFG: BB#3(20) BB#2(12)

BB#3: 
    Predecessors according to CFG: BB#0
    Successors according to CFG: BB#1

BB#1: derived from LLVM BB %for.body
    Predecessors according to CFG: BB#1 BB#3
	%vreg0<def> = PHI %vreg5, <BB#3>, %vreg3, <BB#1>; CPURegs:%vreg0,%vreg5,%vreg3
	%vreg1<def> = PHI %vreg6, <BB#3>, %vreg2, <BB#1>; CPURegs:%vreg1,%vreg6,%vreg2
	%vreg2<def> = MUL %vreg0, %vreg1; CPURegs:%vreg2,%vreg0,%vreg1
	%vreg3<def> = ADDiu %vreg0, -1; CPURegs:%vreg3,%vreg0
	BGTZ %vreg3, <BB#1>, %AT<imp-def,dead>; CPURegs:%vreg3
	B <BB#2>, %AT<imp-def,dead>
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Predecessors according to CFG: BB#0 BB#1
	%vreg4<def> = PHI %vreg6, <BB#0>, %vreg2, <BB#1>; CPURegs:%vreg4,%vreg6,%vreg2
	%V0<def> = COPY %vreg4; CPURegs:%vreg4
	RetRA %V0<imp-use>

# End machine code for function fact.

# After codegen peephole optimization pass:
# Machine code for function fact: SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%vreg5<def> = COPY %A0; CPURegs:%vreg5
	%vreg7<def> = SLTi %vreg5, 1; CPURegs:%vreg7,%vreg5
	%vreg6<def> = ADDiu %ZERO, 1; CPURegs:%vreg6
	BNE %vreg7, %ZERO, <BB#2>, %AT<imp-def>; CPURegs:%vreg7
    Successors according to CFG: BB#3(20) BB#2(12)

BB#3: 
    Predecessors according to CFG: BB#0
    Successors according to CFG: BB#1

BB#1: derived from LLVM BB %for.body
    Predecessors according to CFG: BB#1 BB#3
	%vreg0<def> = PHI %vreg5, <BB#3>, %vreg3, <BB#1>; CPURegs:%vreg0,%vreg5,%vreg3
	%vreg1<def> = PHI %vreg6, <BB#3>, %vreg2, <BB#1>; CPURegs:%vreg1,%vreg6,%vreg2
	%vreg2<def> = MUL %vreg0, %vreg1; CPURegs:%vreg2,%vreg0,%vreg1
	%vreg3<def> = ADDiu %vreg0, -1; CPURegs:%vreg3,%vreg0
	BGTZ %vreg3, <BB#1>, %AT<imp-def,dead>; CPURegs:%vreg3
	B <BB#2>, %AT<imp-def,dead>
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Predecessors according to CFG: BB#0 BB#1
	%vreg4<def> = PHI %vreg6, <BB#0>, %vreg2, <BB#1>; CPURegs:%vreg4,%vreg6,%vreg2
	%V0<def> = COPY %vreg4; CPURegs:%vreg4
	RetRA %V0<imp-use>

# End machine code for function fact.

# After Register Allocation, before rewriter:
# Machine code for function fact: Post SSA
Function Live Ins: %A0 in %vreg5

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %A0
16B		%vreg8<def> = COPY %A0; CPURegs:%vreg8
32B		%vreg7<def> = SLTi %vreg8, 1; CPURegs:%vreg7,%vreg8
48B		%vreg10<def> = ADDiu %ZERO, 1; CPURegs:%vreg10
64B		BEQ %vreg7, %ZERO, <BB#1>, %AT<imp-def>; CPURegs:%vreg7
	    Successors according to CFG: BB#1(20) BB#4(12)

80B	BB#4: 
	    Predecessors according to CFG: BB#0
112B		B <BB#3>, %AT<imp-def>
	    Successors according to CFG: BB#3

128B	BB#1: 
	    Predecessors according to CFG: BB#0
	    Successors according to CFG: BB#2

176B	BB#2: derived from LLVM BB %for.body
	    Predecessors according to CFG: BB#2 BB#1
224B		%vreg10<def> = MUL %vreg8, %vreg10; CPURegs:%vreg10,%vreg8
240B		%vreg8<def> = ADDiu %vreg8, -1; CPURegs:%vreg8
304B		BGTZ %vreg8, <BB#2>, %AT<imp-def,dead>; CPURegs:%vreg8
320B		B <BB#3>, %AT<imp-def,dead>
	    Successors according to CFG: BB#2(124) BB#3(4)

336B	BB#3: derived from LLVM BB %for.end
	    Predecessors according to CFG: BB#2 BB#4
368B		%V0<def> = COPY %vreg10; CPURegs:%vreg10
384B		RetRA %V0<imp-use>

# End machine code for function fact.

# After Virtual Register Rewriter:
# Machine code for function fact: Post SSA
Function Live Ins: %A0 in %vreg5

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %A0
32B		%AT<def> = SLTi %A0, 1
48B		%V0<def> = ADDiu %ZERO, 1
64B		BEQ %AT<kill>, %ZERO, <BB#1>, %AT<imp-def>
	    Successors according to CFG: BB#1(20) BB#4(12)

80B	BB#4: 
	    Live Ins: %V0
	    Predecessors according to CFG: BB#0
112B		B <BB#3>, %AT<imp-def>
	    Successors according to CFG: BB#3

128B	BB#1: 
	    Live Ins: %A0 %V0
	    Predecessors according to CFG: BB#0
	    Successors according to CFG: BB#2

176B	BB#2: derived from LLVM BB %for.body
	    Live Ins: %A0 %V0
	    Predecessors according to CFG: BB#2 BB#1
224B		%V0<def> = MUL %A0, %V0<kill>
240B		%A0<def> = ADDiu %A0<kill>, -1
304B		BGTZ %A0, <BB#2>, %AT<imp-def,dead>
320B		B <BB#3>, %AT<imp-def,dead>
	    Successors according to CFG: BB#2(124) BB#3(4)

336B	BB#3: derived from LLVM BB %for.end
	    Live Ins: %V0
	    Predecessors according to CFG: BB#2 BB#4
384B		RetRA %V0<imp-use>

# End machine code for function fact.

# After StackSlotColoring and postra Machine LICM:
# Machine code for function fact: Post SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%AT<def> = SLTi %A0, 1
	%V0<def> = ADDiu %ZERO, 1
	BEQ %AT<kill>, %ZERO, <BB#1>, %AT<imp-def>
    Successors according to CFG: BB#1(20) BB#4(12)

BB#4: 
    Live Ins: %V0
    Predecessors according to CFG: BB#0
	B <BB#3>, %AT<imp-def>
    Successors according to CFG: BB#3

BB#1: 
    Live Ins: %A0 %V0
    Predecessors according to CFG: BB#0
    Successors according to CFG: BB#2

BB#2: derived from LLVM BB %for.body
    Live Ins: %A0 %V0
    Predecessors according to CFG: BB#2 BB#1
	%V0<def> = MUL %A0, %V0<kill>
	%A0<def> = ADDiu %A0<kill>, -1
	BGTZ %A0, <BB#2>, %AT<imp-def,dead>
	B <BB#3>, %AT<imp-def,dead>
    Successors according to CFG: BB#2(124) BB#3(4)

BB#3: derived from LLVM BB %for.end
    Live Ins: %V0
    Predecessors according to CFG: BB#2 BB#4
	RetRA %V0<imp-use>

# End machine code for function fact.

# After PrologEpilogCodeInserter:
# Machine code for function fact: Post SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%AT<def> = SLTi %A0, 1
	%V0<def> = ADDiu %ZERO, 1
	BEQ %AT<kill>, %ZERO, <BB#1>, %AT<imp-def>
    Successors according to CFG: BB#1(20) BB#4(12)

BB#4: 
    Live Ins: %V0
    Predecessors according to CFG: BB#0
	B <BB#3>, %AT<imp-def>
    Successors according to CFG: BB#3

BB#1: 
    Live Ins: %A0 %V0
    Predecessors according to CFG: BB#0
    Successors according to CFG: BB#2

BB#2: derived from LLVM BB %for.body
    Live Ins: %A0 %V0
    Predecessors according to CFG: BB#2 BB#1
	%V0<def> = MUL %A0, %V0<kill>
	%A0<def> = ADDiu %A0<kill>, -1
	BGTZ %A0, <BB#2>, %AT<imp-def,dead>
	B <BB#3>, %AT<imp-def,dead>
    Successors according to CFG: BB#2(124) BB#3(4)

BB#3: derived from LLVM BB %for.end
    Live Ins: %V0
    Predecessors according to CFG: BB#2 BB#4
	RetRA %V0<imp-use>

# End machine code for function fact.

# After BranchFolding:
# Machine code for function fact: Post SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%AT<def> = SLTi %A0, 1
	%V0<def> = ADDiu %ZERO, 1
	BNE %AT, %ZERO, <BB#2>, %AT<imp-def>
    Successors according to CFG: BB#1(20) BB#2(12)

BB#1: derived from LLVM BB %for.body
    Live Ins: %A0 %V0
    Predecessors according to CFG: BB#1 BB#0
	%V0<def> = MUL %A0, %V0<kill>
	%A0<def> = ADDiu %A0<kill>, -1
	BGTZ %A0, <BB#1>, %AT<imp-def>
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Live Ins: %V0
    Predecessors according to CFG: BB#1 BB#0
	RetRA %V0<imp-use>

# End machine code for function fact.

# After TailDuplicate:
# Machine code for function fact: Post SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%AT<def> = SLTi %A0, 1
	%V0<def> = ADDiu %ZERO, 1
	BNE %AT, %ZERO, <BB#2>, %AT<imp-def>
    Successors according to CFG: BB#1(20) BB#2(12)

BB#1: derived from LLVM BB %for.body
    Live Ins: %A0 %V0
    Predecessors according to CFG: BB#1 BB#0
	%V0<def> = MUL %A0, %V0<kill>
	%A0<def> = ADDiu %A0<kill>, -1
	BGTZ %A0, <BB#1>, %AT<imp-def>
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Live Ins: %V0
    Predecessors according to CFG: BB#1 BB#0
	RetRA %V0<imp-use>

# End machine code for function fact.

# After copy propagation pass:
# Machine code for function fact: Post SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%AT<def> = SLTi %A0, 1
	%V0<def> = ADDiu %ZERO, 1
	BNE %AT, %ZERO, <BB#2>, %AT<imp-def>
    Successors according to CFG: BB#1(20) BB#2(12)

BB#1: derived from LLVM BB %for.body
    Live Ins: %A0 %V0
    Predecessors according to CFG: BB#1 BB#0
	%V0<def> = MUL %A0, %V0<kill>
	%A0<def> = ADDiu %A0<kill>, -1
	BGTZ %A0, <BB#1>, %AT<imp-def>
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Live Ins: %V0
    Predecessors according to CFG: BB#1 BB#0
	RetRA %V0<imp-use>

# End machine code for function fact.

# After ExpandPostRAPseudos:
# Machine code for function fact: Post SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%AT<def> = SLTi %A0, 1
	%V0<def> = ADDiu %ZERO, 1
	BNE %AT, %ZERO, <BB#2>, %AT<imp-def>
    Successors according to CFG: BB#1(20) BB#2(12)

BB#1: derived from LLVM BB %for.body
    Live Ins: %A0 %V0
    Predecessors according to CFG: BB#1 BB#0
	%V0<def> = MUL %A0, %V0<kill>
	%A0<def> = ADDiu %A0<kill>, -1
	BGTZ %A0, <BB#1>, %AT<imp-def>
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Live Ins: %V0
    Predecessors according to CFG: BB#1 BB#0
	RET %RA

# End machine code for function fact.

# After PostRAScheduler:
# Machine code for function fact: Post SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%AT<def> = SLTi %A0, 1
	%V0<def> = ADDiu %ZERO, 1
	BNE %AT, %ZERO, <BB#2>, %AT<imp-def>
    Successors according to CFG: BB#1(20) BB#2(12)

BB#1: derived from LLVM BB %for.body
    Live Ins: %A0 %V0
    Predecessors according to CFG: BB#1 BB#0
	%V0<def> = MUL %A0, %V0<kill>
	%A0<def> = ADDiu %A0<kill>, -1
	BGTZ %A0, <BB#1>, %AT<imp-def>
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Live Ins: %V0
    Predecessors according to CFG: BB#1 BB#0
	RET %RA

# End machine code for function fact.

# After machine block placement.:
# Machine code for function fact: Post SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%AT<def> = SLTi %A0, 1
	%V0<def> = ADDiu %ZERO, 1
	BNE %AT, %ZERO, <BB#2>, %AT<imp-def>
    Successors according to CFG: BB#1(20) BB#2(12)

BB#1: derived from LLVM BB %for.body
    Live Ins: %A0 %V0
    Predecessors according to CFG: BB#1 BB#0
	%V0<def> = MUL %A0, %V0<kill>
	%A0<def> = ADDiu %A0<kill>, -1
	BGTZ %A0, <BB#1>, %AT<imp-def>
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Live Ins: %V0
    Predecessors according to CFG: BB#1 BB#0
	RET %RA

# End machine code for function fact.

# After PreEmit passes:
# Machine code for function fact: Post SSA
Function Live Ins: %A0 in %vreg5

BB#0: derived from LLVM BB %entry
    Live Ins: %A0
	%AT<def> = SLTi %A0, 1
	BNE %AT, %ZERO, <BB#2>, %AT<imp-def>
	  * %V0<def> = ADDiu %ZERO, 1
    Successors according to CFG: BB#1(20) BB#2(12)

BB#1: derived from LLVM BB %for.body
    Live Ins: %A0 %V0
    Predecessors according to CFG: BB#1 BB#0
	%V0<def> = MUL %A0, %V0<kill>
	%A0<def> = ADDiu %A0<kill>, -1
	BGTZ %A0, <BB#1>, %AT<imp-def>
	  * NOP
    Successors according to CFG: BB#1(124) BB#2(4)

BB#2: derived from LLVM BB %for.end
    Live Ins: %V0
    Predecessors according to CFG: BB#1 BB#0
	RET %RA
	  * NOP

# End machine code for function fact.

# After Instruction Selection:
# Machine code for function main: SSA
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0
	%vreg0<def> = ADDu %V0, %T9; CPURegs:%vreg0
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg1<def> = LW %vreg0, <ga:@fact>[TF=3]; mem:LD4[GOT] CPURegs:%vreg1,%vreg0
	%vreg2<def> = ADDiu %ZERO, 10; CPURegs:%vreg2
	%T9<def> = COPY %vreg1; CPURegs:%vreg1
	%A0<def> = COPY %vreg2; CPURegs:%vreg2
	%GP<def> = COPY %vreg0; CPURegs:%vreg0
	JALRPseudo %T9, <regmask>, %A0<imp-use>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>, ...
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg3<def> = COPY %V0; CPURegs:%vreg3
	%V0<def> = COPY %vreg3; CPURegs:%vreg3
	RetRA %V0<imp-use>

# End machine code for function main.

# After ExpandISelPseudos:
# Machine code for function main: SSA
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0
	%vreg0<def> = ADDu %V0, %T9; CPURegs:%vreg0
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg1<def> = LW %vreg0, <ga:@fact>[TF=3]; mem:LD4[GOT] CPURegs:%vreg1,%vreg0
	%vreg2<def> = ADDiu %ZERO, 10; CPURegs:%vreg2
	%T9<def> = COPY %vreg1; CPURegs:%vreg1
	%A0<def> = COPY %vreg2; CPURegs:%vreg2
	%GP<def> = COPY %vreg0; CPURegs:%vreg0
	JALRPseudo %T9, <regmask>, %A0<imp-use>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>, ...
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg3<def> = COPY %V0; CPURegs:%vreg3
	%V0<def> = COPY %vreg3; CPURegs:%vreg3
	RetRA %V0<imp-use>

# End machine code for function main.

# After Pre-RegAlloc TailDuplicate:
# Machine code for function main: SSA
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0
	%vreg0<def> = ADDu %V0, %T9; CPURegs:%vreg0
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg1<def> = LW %vreg0, <ga:@fact>[TF=3]; mem:LD4[GOT] CPURegs:%vreg1,%vreg0
	%vreg2<def> = ADDiu %ZERO, 10; CPURegs:%vreg2
	%T9<def> = COPY %vreg1; CPURegs:%vreg1
	%A0<def> = COPY %vreg2; CPURegs:%vreg2
	%GP<def> = COPY %vreg0; CPURegs:%vreg0
	JALRPseudo %T9, <regmask>, %A0<imp-use>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>, ...
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg3<def> = COPY %V0; CPURegs:%vreg3
	%V0<def> = COPY %vreg3; CPURegs:%vreg3
	RetRA %V0<imp-use>

# End machine code for function main.

# After codegen DCE pass:
# Machine code for function main: SSA
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0
	%vreg0<def> = ADDu %V0, %T9; CPURegs:%vreg0
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg1<def> = LW %vreg0, <ga:@fact>[TF=3]; mem:LD4[GOT] CPURegs:%vreg1,%vreg0
	%vreg2<def> = ADDiu %ZERO, 10; CPURegs:%vreg2
	%T9<def> = COPY %vreg1; CPURegs:%vreg1
	%A0<def> = COPY %vreg2; CPURegs:%vreg2
	%GP<def> = COPY %vreg0; CPURegs:%vreg0
	JALRPseudo %T9, <regmask>, %A0<imp-use>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>, ...
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg3<def> = COPY %V0; CPURegs:%vreg3
	%V0<def> = COPY %vreg3; CPURegs:%vreg3
	RetRA %V0<imp-use>

# End machine code for function main.

# After Machine LICM, CSE and Sinking passes:
# Machine code for function main: SSA
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0
	%vreg0<def> = ADDu %V0, %T9; CPURegs:%vreg0
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg1<def> = LW %vreg0, <ga:@fact>[TF=3]; mem:LD4[GOT] CPURegs:%vreg1,%vreg0
	%vreg2<def> = ADDiu %ZERO, 10; CPURegs:%vreg2
	%T9<def> = COPY %vreg1; CPURegs:%vreg1
	%A0<def> = COPY %vreg2; CPURegs:%vreg2
	%GP<def> = COPY %vreg0; CPURegs:%vreg0
	JALRPseudo %T9, <regmask>, %A0<imp-use>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>, ...
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg3<def> = COPY %V0; CPURegs:%vreg3
	%V0<def> = COPY %vreg3; CPURegs:%vreg3
	RetRA %V0<imp-use>

# End machine code for function main.

# After codegen peephole optimization pass:
# Machine code for function main: SSA
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0
	%vreg0<def> = ADDu %V0, %T9; CPURegs:%vreg0
	ADJCALLSTACKDOWN 16, %SP<imp-def,dead>, %SP<imp-use>
	%vreg1<def> = LW %vreg0, <ga:@fact>[TF=3]; mem:LD4[GOT] CPURegs:%vreg1,%vreg0
	%vreg2<def> = ADDiu %ZERO, 10; CPURegs:%vreg2
	%T9<def> = COPY %vreg1; CPURegs:%vreg1
	%A0<def> = COPY %vreg2; CPURegs:%vreg2
	%GP<def> = COPY %vreg0; CPURegs:%vreg0
	JALRPseudo %T9, <regmask>, %A0<imp-use>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>, ...
	ADJCALLSTACKUP 16, 0, %SP<imp-def,dead>, %SP<imp-use>
	%vreg3<def> = COPY %V0; CPURegs:%vreg3
	%V0<def> = COPY %vreg3; CPURegs:%vreg3
	RetRA %V0<imp-use>

# End machine code for function main.

# After Register Allocation, before rewriter:
# Machine code for function main: Post SSA
Function Live Ins: %T9, %V0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %T9 %V0
16B		%vreg0<def> = ADDu %V0, %T9; CPURegs:%vreg0
32B		ADJCALLSTACKDOWN 16, %SP<imp-def>, %SP<imp-use>
48B		%vreg1<def> = LW %vreg0, <ga:@fact>[TF=3]; mem:LD4[GOT] CPURegs:%vreg1,%vreg0
80B		%T9<def> = COPY %vreg1; CPURegs:%vreg1
96B		%A0<def> = ADDiu %ZERO, 10
112B		%GP<def> = COPY %vreg0; CPURegs:%vreg0
128B		JALRPseudo %T9, <regmask>, %A0<imp-use,kill>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>, ...
144B		ADJCALLSTACKUP 16, 0, %SP<imp-def>, %SP<imp-use>
160B		%vreg3<def> = COPY %V0; CPURegs:%vreg3
176B		%V0<def> = COPY %vreg3; CPURegs:%vreg3
192B		RetRA %V0<imp-use>

# End machine code for function main.

# After Virtual Register Rewriter:
# Machine code for function main: Post SSA
Function Live Ins: %T9, %V0

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %T9 %V0
16B		%GP<def> = ADDu %V0, %T9
32B		ADJCALLSTACKDOWN 16, %SP<imp-def>, %SP<imp-use>
48B		%T9<def> = LW %GP, <ga:@fact>[TF=3]; mem:LD4[GOT]
96B		%A0<def> = ADDiu %ZERO, 10
128B		JALRPseudo %T9, <regmask>, %A0<imp-use,kill>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>, ...
144B		ADJCALLSTACKUP 16, 0, %SP<imp-def>, %SP<imp-use>
192B		RetRA %V0<imp-use>

# End machine code for function main.

# After StackSlotColoring and postra Machine LICM:
# Machine code for function main: Post SSA
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0
	%GP<def> = ADDu %V0, %T9
	ADJCALLSTACKDOWN 16, %SP<imp-def>, %SP<imp-use>
	%T9<def> = LW %GP, <ga:@fact>[TF=3]; mem:LD4[GOT]
	%A0<def> = ADDiu %ZERO, 10
	JALRPseudo %T9, <regmask>, %A0<imp-use,kill>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>, ...
	ADJCALLSTACKUP 16, 0, %SP<imp-def>, %SP<imp-use>
	RetRA %V0<imp-use>

# End machine code for function main.

# After PrologEpilogCodeInserter:
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0 %RA
	%SP<def> = ADDiu %SP, -24
	PROLOG_LABEL <MCSym=$tmp1>
	SW %RA<kill>, %SP, 20; mem:ST4[FixedStack0]
	PROLOG_LABEL <MCSym=$tmp2>
	%GP<def> = ADDu %V0, %T9
	%T9<def> = LW %GP, <ga:@fact>[TF=3]; mem:LD4[GOT]
	%A0<def> = ADDiu %ZERO, 10
	JALRPseudo %T9, <regmask>, %RA<imp-def,dead>, %A0<imp-use,kill>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>
	%RA<def> = LW %SP, 20; mem:LD4[FixedStack0]
	%SP<def> = ADDiu %SP, 24
	RetRA %V0<imp-use>

# End machine code for function main.

# After BranchFolding:
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0 %RA
	%SP<def> = ADDiu %SP, -24
	PROLOG_LABEL <MCSym=$tmp1>
	SW %RA<kill>, %SP, 20; mem:ST4[FixedStack0]
	PROLOG_LABEL <MCSym=$tmp2>
	%GP<def> = ADDu %V0, %T9
	%T9<def> = LW %GP, <ga:@fact>[TF=3]; mem:LD4[GOT]
	%A0<def> = ADDiu %ZERO, 10
	JALRPseudo %T9, <regmask>, %RA<imp-def,dead>, %A0<imp-use,kill>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>
	%RA<def> = LW %SP, 20; mem:LD4[FixedStack0]
	%SP<def> = ADDiu %SP, 24
	RetRA %V0<imp-use>

# End machine code for function main.

# After TailDuplicate:
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0 %RA
	%SP<def> = ADDiu %SP, -24
	PROLOG_LABEL <MCSym=$tmp1>
	SW %RA<kill>, %SP, 20; mem:ST4[FixedStack0]
	PROLOG_LABEL <MCSym=$tmp2>
	%GP<def> = ADDu %V0, %T9
	%T9<def> = LW %GP, <ga:@fact>[TF=3]; mem:LD4[GOT]
	%A0<def> = ADDiu %ZERO, 10
	JALRPseudo %T9, <regmask>, %RA<imp-def,dead>, %A0<imp-use,kill>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>
	%RA<def> = LW %SP, 20; mem:LD4[FixedStack0]
	%SP<def> = ADDiu %SP, 24
	RetRA %V0<imp-use>

# End machine code for function main.

# After copy propagation pass:
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0 %RA
	%SP<def> = ADDiu %SP, -24
	PROLOG_LABEL <MCSym=$tmp1>
	SW %RA<kill>, %SP, 20; mem:ST4[FixedStack0]
	PROLOG_LABEL <MCSym=$tmp2>
	%GP<def> = ADDu %V0, %T9
	%T9<def> = LW %GP, <ga:@fact>[TF=3]; mem:LD4[GOT]
	%A0<def> = ADDiu %ZERO, 10
	JALRPseudo %T9, <regmask>, %RA<imp-def,dead>, %A0<imp-use,kill>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>
	%RA<def> = LW %SP, 20; mem:LD4[FixedStack0]
	%SP<def> = ADDiu %SP, 24
	RetRA %V0<imp-use>

# End machine code for function main.

# After ExpandPostRAPseudos:
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0 %RA
	%SP<def> = ADDiu %SP, -24
	PROLOG_LABEL <MCSym=$tmp1>
	SW %RA<kill>, %SP, 20; mem:ST4[FixedStack0]
	PROLOG_LABEL <MCSym=$tmp2>
	%GP<def> = ADDu %V0, %T9
	%T9<def> = LW %GP, <ga:@fact>[TF=3]; mem:LD4[GOT]
	%A0<def> = ADDiu %ZERO, 10
	JALRPseudo %T9, <regmask>, %RA<imp-def,dead>, %A0<imp-use,kill>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>
	%RA<def> = LW %SP, 20; mem:LD4[FixedStack0]
	%SP<def> = ADDiu %SP, 24
	RET %RA

# End machine code for function main.

# After PostRAScheduler:
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0 %RA
	%SP<def> = ADDiu %SP, -24
	PROLOG_LABEL <MCSym=$tmp1>
	SW %RA<kill>, %SP, 20; mem:ST4[FixedStack0]
	PROLOG_LABEL <MCSym=$tmp2>
	%GP<def> = ADDu %V0, %T9
	%T9<def> = LW %GP, <ga:@fact>[TF=3]; mem:LD4[GOT]
	%A0<def> = ADDiu %ZERO, 10
	JALRPseudo %T9, <regmask>, %RA<imp-def,dead>, %A0<imp-use,kill>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>
	%RA<def> = LW %SP, 20; mem:LD4[FixedStack0]
	%SP<def> = ADDiu %SP, 24
	RET %RA

# End machine code for function main.

# After machine block placement.:
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %V0 %RA
	%SP<def> = ADDiu %SP, -24
	PROLOG_LABEL <MCSym=$tmp1>
	SW %RA<kill>, %SP, 20; mem:ST4[FixedStack0]
	PROLOG_LABEL <MCSym=$tmp2>
	%GP<def> = ADDu %V0, %T9
	%T9<def> = LW %GP, <ga:@fact>[TF=3]; mem:LD4[GOT]
	%A0<def> = ADDiu %ZERO, 10
	JALRPseudo %T9, <regmask>, %RA<imp-def,dead>, %A0<imp-use,kill>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>
	%RA<def> = LW %SP, 20; mem:LD4[FixedStack0]
	%SP<def> = ADDiu %SP, 24
	RET %RA

# End machine code for function main.

# After PreEmit passes:
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
Function Live Ins: %T9, %V0

BB#0: derived from LLVM BB %entry
    Live Ins: %T9 %RA
	%V0<def> = LUi <es:_gp_disp>[TF=5]
	%V0<def> = ADDiu %V0, <es:_gp_disp>[TF=6]
	%SP<def> = ADDiu %SP, -24
	PROLOG_LABEL <MCSym=$tmp1>
	SW %RA<kill>, %SP, 20; mem:ST4[FixedStack0]
	PROLOG_LABEL <MCSym=$tmp2>
	%GP<def> = ADDu %V0, %T9
	%T9<def> = LW %GP, <ga:@fact>[TF=3]; mem:LD4[GOT]
	JALRPseudo %T9, <regmask>, %RA<imp-def,dead>, %A0<imp-use,kill>, %GP<imp-use>, %SP<imp-def>, %V0<imp-def>
	  * %A0<def> = ADDiu %ZERO, 10
	%RA<def> = LW %SP, 20; mem:LD4[FixedStack0]
	RET %RA
	  * %SP<def> = ADDiu %SP, 24

# End machine code for function main.

