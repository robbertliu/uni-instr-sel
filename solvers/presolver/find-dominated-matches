#!/usr/bin/python

#  Main authors:
#    Gabriel Hjort Blindell <ghb@kth.se>
#    Mats Carlsson <mats.carlsson@ri.se>
#
#  Copyright (c) 2012-2017, Gabriel Hjort Blindell <ghb@kth.se>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions are met:
#  1. Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#  3. Neither the name of the copyright holder nor the names of its contributors
#     may be used to endorse or promote products derived from this software
#     without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
#  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



#=========
# IMPORTS
#=========

import json
import os.path
import sys



#================
# HELP FUNCTIONS
#================

def error(msg):
    sys.stderr.write("ERROR: " + msg + "\n")
    sys.exit(1)

# A match m1 dominates another match m2 if:
#    - neither is a null instruction,
#    - neither match occurs in the parameters "same-loc", "in-block", and
#      "in-block-succ" (TODO: relax?),
#    - the tuple <latency of m1, index of m1> is lexicographically smaller than
#      the tuple <latency of m2, index of m2>,
#    - both matches cover exactly the same operations,
#    - both matches define exactly the same data,
#    - both matches use exactly the same data,
#    - both matches have the same entry block,
#    - both matches span across the same blocks,
#    - both matches apply the def-dom-use constraint,
#    - if m1 defines any constraints in the parameters "match-valid-value-locs"
#      or "match-valid-value-loc-ranges", then m2 defines constraints that are
#      at least as strong,
#      and
#    - both matches have exactly the same auxiliary constraints (TODO: relax?).
def matchesDominatedBy(json, m1, dominable_matches):
    def computeDominableMatchsetCandidates():
        def findMatchesCovering(ops_to_cover, m_cands, selected_ms):
            if len(ops_to_cover) == 0:
                return selected_ms

            all_solutions = []
            for i in range(len(m_cands)):
                m = m_cands[i]
                m_op_cover_set = set(json["match-operations-covered"][m])
                if m_op_cover_set <= ops_to_cover:
                    remaining_ops = ops_to_cover - m_op_cover_set
                    remaining_ms = [n for n in m_cands if n != m]
                    if len(selected_ms) > 0:
                        new_selected_ms = [ ms + [m] for ms in selected_ms ]
                    else:
                        new_selected_ms = [[m]]
                    solutions = findMatchesCovering(remaining_ops,
                                                    remaining_ms,
                                                    new_selected_ms)
                    all_solutions = ( all_solutions +
                                      [ set(ms) for ms in solutions
                                        if set(ms) not in all_solutions
                                      ]
                                    )
            return [ list(ms) for ms in all_solutions ]

        # Gather combinations of matches that collectively cover the same
        # operations as m1
        m1_op_cover_set = set(json["match-operations-covered"][m1])
        ms_covering_same_ops = [ m for m in dominable_matches
                                 if m != m1 and
                                    set(json["match-operations-covered"][m]) <=
                                    m1_op_cover_set
                               ]
        return findMatchesCovering(m1_op_cover_set, ms_covering_same_ops, [])

    def hasLessOrEqualCost(ms):
        ms_cost = 0
        for m2 in ms:
            ms_cost = ms_cost + json["match-latencies"][m2]
        return ( json["match-latencies"][m1] < ms_cost or
                 ( json["match-latencies"][m1] == ms_cost and
                   ( len(ms) > 1 or m1 < m2 )
                 )
               )

    def hasSameEntry(ms):
        m1_entry = json["match-entry-blocks"][m1]
        if m1_entry is not None:
            m1_entry = set([m1_entry])
        else:
            m1_entry = set()
        ms_entries = set()
        for m in ms:
            m_entry = json["match-entry-blocks"][m]
            if m_entry is not None:
                ms_entries.add(m_entry)
        return m1_entry == ms_entries

    def spansSameBlocks(ms):
        m1_spanned = set(json["match-spanned-blocks"][m1])
        ms_spanned = set()
        for m in ms:
            ms_spanned.update(set(json["match-spanned-blocks"][m]))
        return m1_spanned == ms_spanned

    def hasNoConflictingDefEdges(ms):
        # Check edges imposed by function graph
        m1_data = ( set([ d for p in json["match-operands-defined"][m1]
                            for d in json["operand-alternatives"][p]
                        ]) |
                    set([ d for p in json["match-operands-used"][m1]
                            for d in json["operand-alternatives"][p]
                        ])
                  )
        f_def_blocks = set()
        for t in json["fun-value-def-edges"]:
            if t[1] in m1_data:
                f_def_blocks.add(t[0])
        for t in json["fun-state-def-edges"]:
            if t[1] in m1_data:
                f_def_blocks.add(t[0])

        # Check edges imposed by candidate set
        ms_def_blocks = set()
        for t in json["match-input-def-edges"]:
            if t[0] in ms:
                ms_def_blocks.add(t[1])
        for t in json["match-output-def-edges"]:
            if t[0] in ms:
                ms_def_blocks.add(t[1])
        return (len(f_def_blocks) < 2 and len(ms_def_blocks) < 2)

    def areLocDomainsAtLeastAsStrong(ms):
        # TODO: implement
        return False

#        O = json["operand-alternatives"]
#
#        # Check match-valid-value-locs constraints
#        locs = json["match-valid-value-locs"]
#        R = range(len(locs))
#        for i in [ i for i in R if locs[i][0] == m1]:
#            # Find constraint in m2 that is at least as strong
#            found = False
#            for j in [ j for j in R if locs[j][0] == m2 ]:
#                if sorted(O[locs[i][1]]) == sorted(O[locs[j][1]]):
#                    reg2 = locs[j][2]
#                    reg1 = locs[i][2]
#                    if reg1 == reg2:
#                        found = True
#                        break
#
#            # No such constraint found
#            if not found:
#                return False
#
#        # Check match-valid-value-loc-ranges constraints
#        loc_ranges = json["match-valid-value-loc-ranges"]
#        R = range(len(loc_ranges))
#        for i in [ i for i in R if loc_ranges[i][0] == m1]:
#            # Find constraint in m2 that is at least as strong
#            found = False
#            for j in [ j for j in R if loc_ranges[j][0] == m2 ]:
#                if sorted(O[loc_ranges[i][1]]) == sorted(O[loc_ranges[j][1]]):
#                    regs2 = set(range(loc_ranges[j][2], loc_ranges[j][3]+1))
#                    regs1 = set(range(loc_ranges[i][2], loc_ranges[i][3]+1))
#                    if regs2.issubset(regs1):
#                        found = True
#                        break
#
#            # No such constraint found
#            if not found:
#                return False
#
#        # All checks have passed
#        return True

    def hasSameConstraints(ms):
        m1_cons = set(json["match-constraints"][m1])
        ms_cons = set()
        for m in ms:
            ms_cons.update(json["match-constraints"][m])
        return m1_cons == ms_cons



    dominable_matchset_candidates = computeDominableMatchsetCandidates()

    # Check that no internal values of the dominator match are used by any
    # matches not in the dominable matchsets
    no_use_of_int_values = False
    m1_int_values = set([ d for p in json["match-internal-operands"][m1]
                            for d in json["operand-alternatives"][p]
                        ])
    all_dom_ms = set([ m for ms in dominable_matchset_candidates for m in ms ])
    for m2 in [m for m in dominable_matches if m != m1 and m not in all_dom_ms]:
        for p in json["match-operands-used"][m2]:
            d = json["operand-alternatives"][p]
            if set(d) <= m1_int_values:
                # Use of m1's internal values; m1 is not eligable as a dominator
                return []

    # Check all eligable matches
    dom_matches = set()
    for ms in [ms for ms in dominable_matchset_candidates]:
        if ( hasLessOrEqualCost(ms) and
             hasSameEntry(ms) and
             spansSameBlocks(ms) and
             hasNoConflictingDefEdges(ms) and
             areLocDomainsAtLeastAsStrong(ms) and
             hasSameConstraints(ms)
           ):
            dom_matches.update(ms)

    return list(dom_matches)



#=============
# MAIN SCRIPT
#=============

# Check arguments
if len(sys.argv) < 2:
    sys.stderr.write("No JSON file given\n")
    sys.exit(1)
if len(sys.argv) > 2:
    sys.stderr.write("Too many arguments\n")
    sys.exit(1)
json_file = sys.argv[1]
if not os.path.isfile(json_file):
    error("JSON file '" + json_file +"' not found")

# Read JSON file
json_data = {}
with open(json_file, 'r') as file:
    json_data = json.load(file)

# Gather matches eligable for domination
excl_matches = \
  ( set(json_data["match-null-instrs"]) |
    set([ int(t[0]) for t in json_data["match-same-value-locs"] ]) |
    set([ int(t[0]) for t in json_data["match-fall-through-block"] ]) |
    set([ m for m in range(json_data["num-matches"])
          if len(json_data["match-operations-covered"][m]) == 0
        ])
  )
dominator_candidates = [ m for m in range(json_data["num-matches"])
                                    if m not in excl_matches
                       ]
dominable_matches = dominator_candidates

# Computed dominated matches
dominated_match_sublists = [ matchesDominatedBy(json_data, m, dominable_matches)
                             for m in dominator_candidates
                           ]
dominated_match_set = set([ m for ms in dominated_match_sublists for m in ms])

d_json_data = {}
d_json_data["dominated-matches-ai"] = list(dominated_match_set)

# Print JSON
print json.dumps(d_json_data)
