#!/usr/bin/python

# Copyright (c) 2013-2015, Gabriel Hjort Blindell <ghb@kth.se>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.



#=========
# IMPORTS
#=========

import json
import sexparser
import os.path
import sys



#================
# HELP FUNCTIONS
#================

def error(msg):
    sys.stderr.write("ERROR: " + msg + "\n")
    sys.exit(1)

def parseSExpr(s):
    return sexparser.parse(s)

# Takes an S-expression object and checks if it corresponds to the
# 'fun-loc-domain' parameter. If so, the corresponding JSON data is returned;
# otherwise 'None' is returned.
def convert2FunLocDomainParam(l):
    if ( len(l) == 3 and l[0] == "in-set"
         and len(l[1]) == 2 and l[1][0] == "loc-to-set-elem"
         and len(l[1][1]) == 2 and l[1][1][0] == "loc-of-dnode"
         and len(l[1][1][1]) == 2 and l[1][1][1][0] == "ai"
         and len(l[2]) == 2 and l[2][0] == "loc-class"
       ):
        loc_class = []
        for k in l[2][1]:
            if k[0] == "ai":
                loc_class.append(int(k[1]))
            else:
                return None

        # Remove possible duplicates and then sort the list
        loc_class = sorted(list(set(loc_class)))

        # Check if the list is a contiguous range
        loc_min = loc_class[0]
        loc_max = loc_class[-1]
        if len(loc_class) - 1 == loc_max - loc_min:
            return [int(l[1][1][1][1]), loc_min, loc_max]
    elif ( len(l) == 3 and l[0] == "=="
           and len(l[1]) == 2 and l[1][0] == "loc-to-num"
           and len(l[2]) == 2 and l[2][0] == "loc-to-num"
         ):
        if ( len(l[1][1]) == 2 and l[1][1][0] == "loc-of-dnode"
             and len(l[1][1][1]) == 2 and l[1][1][1][0] == "ai"
             and l[2][1] == "null"
           ):
            return [int(l[1][1][1][1]), None, None]
        elif ( l[1][1] == "null"
               and len(l[2][1]) == 2 and l[2][1][0] == "loc-of-dnode"
               and len(l[2][1][1]) == 2 and l[2][1][1][0] == "ai"
             ):
            return [int(l[2][1][1][1]), None, None]
        elif ( len(l[1][1]) == 2 and l[1][1][0] == "loc-of-dnode"
               and len(l[1][1][1]) == 2 and l[1][1][1][0] == "ai"
               and len(l[2][1]) == 2 and l[2][1][0] == "ai"
             ):
            loc = int(l[2][1][1])
            return [int(l[1][1][1][1]), loc, loc]
        elif ( len(l[1][1]) == 2 and l[1][1][0] == "ai"
               and len(l[2][1]) == 2 and l[2][1][0] == "loc-of-dnode"
               and len(l[2][1][1]) == 2 and l[2][1][1][0] == "ai"
             ):
            loc = int(l[1][1][1])
            return [int(l[2][1][1][1]), loc, loc]
    return None

# Takes an S-expression object and checks if it corresponds to a
# 'match-loc-domain' parameter. If so, the corresponding JSON data is returned;
# otherwise 'None' is returned.
def convert2MatchLocDomainParam(l):
    if ( len(l) == 3 and l[0] == "in-set"
         and len(l[1]) == 2 and l[1][0] == "loc-to-set-elem"
         and len(l[1][1]) == 2 and l[1][1][0] == "loc-of-dnode"
         and len(l[1][1][1]) == 2 and l[1][1][1][0] == "node-selected-for-op"
         and len(l[1][1][1][1]) == 2 and l[1][1][1][1][0] == "ai"
         and len(l[2]) == 2 and l[2][0] == "loc-class"
       ):
        loc_class = []
        for k in l[2][1]:
            if k[0] == "ai":
                loc_class.append(int(k[1]))
            else:
                return None

        # Remove possible duplicates and then sort the list
        loc_class = sorted(list(set(loc_class)))

        # Check if the list is a contiguous range
        loc_min = loc_class[0]
        loc_max = loc_class[-1]
        if len(loc_class) - 1 == loc_max - loc_min:
            return [int(l[1][1][1][1][1]), loc_min, loc_max]
    elif ( len(l) == 3 and l[0] == "=="
           and len(l[1]) == 2 and l[1][0] == "loc-to-num"
           and len(l[2]) == 2 and l[2][0] == "loc-to-num"
         ):
        if ( len(l[1][1]) == 2 and l[1][1][0] == "loc-of-dnode"
             and len(l[1][1][1]) == 2
             and l[1][1][1][0] == "node-selected-for-op"
             and len(l[1][1][1][1]) == 2 and l[1][1][1][1][0] == "ai"
             and l[2][1] == "null"
           ):
            return [int(l[1][1][1][1][1]), None, None]
        elif ( l[1][1] == "null"
               and len(l[2][1]) == 2 and l[2][1][0] == "loc-of-dnode"
               and len(l[2][1][1]) == 2
               and l[2][1][1][0] == "node-selected-for-op"
               and len(l[2][1][1][1]) == 2 and l[2][1][1][1][0] == "ai"
             ):
            return [int(l[2][1][1][1][1]), None, None]
        elif ( len(l[1][1]) == 2 and l[1][1][0] == "loc-of-dnode"
               and len(l[1][1][1]) == 2
               and l[1][1][1][0] == "node-selected-for-op"
               and len(l[1][1][1][1]) == 2 and l[1][1][1][1][0] == "ai"
               and len(l[2][1]) == 2 and l[2][1][0] == "ai"
             ):
            loc = int(l[2][1][1])
            return [int(l[1][1][1][1][1]), loc, loc]
        elif ( len(l[1][1]) == 2 and l[1][1][0] == "ai"
               and len(l[2][1]) == 2 and l[2][1][0] == "loc-of-dnode"
               and len(l[2][1][1]) == 2
               and l[2][1][1][0] == "node-selected-for-op"
               and len(l[2][1][1][1]) == 2 and l[2][1][1][1][0] == "ai"
             ):
            loc = int(l[1][1][1])
            return [int(l[2][1][1][1][1]), loc, loc]
    return None



#=============
# MAIN SCRIPT
#=============

# Check files
if len(sys.argv) < 2:
    sys.stderr.write("No JSON file given\n")
    sys.exit(1)
if len(sys.argv) > 2:
    sys.stderr.write("Too many arguments\n")
    sys.exit(1)
json_file = sys.argv[1]
if not os.path.isfile(json_file):
    error("JSON file '" + json_file + "' not found")

# Read JSON file
json_data = []
with open(json_file, 'r') as file:
    json_data = json.load(file)

json_m_cons = json_data["match-constraints"]

# Produce 'same-loc' parameters
params = []
for i in range(len(json_m_cons)):
    new_constraints = []
    for c in json_m_cons[i]:
        l = parseSExpr(c)
        if ( len(l) == 3 and l[0] == "=="
             and len(l[1]) == 2 and l[1][0] == "loc-to-num"
             and len(l[1][1]) == 2 and l[1][1][0] == "loc-of-dnode"
             and len(l[1][1][1]) == 2 and l[1][1][1][0] == "ai"
             and len(l[2]) == 2 and l[2][0] == "loc-to-num"
             and len(l[2][1]) == 2 and l[2][1][0] == "loc-of-dnode"
             and len(l[2][1][1]) == 2 and l[2][1][1][0] == "ai"
           ):
            params.append([i, int(l[1][1][1][1]), int(l[2][1][1][1])])
        else:
            new_constraints.append(c)
    json_m_cons[i] = new_constraints
json_data["same-loc"] = params

# Produce 'in-block' parameters
params = []
for i in range(len(json_m_cons)):
    # Check constraints
    new_constraints = []
    for c in json_m_cons[i]:
        l = parseSExpr(c)
        if ( len(l) == 3 and l[0] == "=="
             and len(l[1]) == 2 and l[1][0] == "block-to-num"
             and len(l[1][1]) == 2 and l[1][1][0] == "block-of-bnode"
             and len(l[1][1][1]) == 2 and l[1][1][1][0] == "ai"
             and len(l[2]) == 2 and l[2][0] == "block-to-num"
             and len(l[2][1]) == 2
             and l[2][1][0] == "block-wherein-match-is-placed"
             and len(l[2][1][1]) == 2 and l[2][1][1][0] == "ai"
           ):
            params.append([int(l[2][1][1][1]), int(l[1][1][1][1])])
        elif ( len(l) == 3 and l[0] == "=="
               and len(l[1]) == 2 and l[1][0] == "block-to-num"
               and len(l[1]) == 2 and l[1][0] == "block-to-num"
               and len(l[1][1]) == 2
               and l[1][1][0] == "block-wherein-match-is-placed"
               and len(l[1][1][1]) == 2 and l[1][1][1][0] == "ai"
               and len(l[2][1]) == 2 and l[2][1][0] == "block-of-bnode"
               and len(l[2][1][1]) == 2 and l[2][1][1][0] == "ai"
             ):
            params.append([int(l[1][1][1][1]), int(l[2][1][1][1])])
        else:
            new_constraints.append(c)
    json_m_cons[i] = new_constraints

    # Check entry-block settings
    entry_block = json_data["match-entry-blocks"][i]
    if entry_block is not None:
        params.append([i, entry_block])
json_data["in-block"] = params

# Produce 'in-block-succ' parameters
params = []
for i in range(len(json_m_cons)):
    new_constraints = []
    for c in json_m_cons[i]:
        is_c_obsolete = False
        l = parseSExpr(c)
        if ( len(l) == 3 and l[0] == "fall-through"
             and len(l[1]) == 2 and l[1][0] == "ai"
             and len(l[2]) == 2 and l[2][0] == "block-of-bnode"
             and len(l[2][1]) == 2 and l[2][1][0] == "ai"
           ):
            m = int(l[1][1])
            b = int(l[2][1][1])
            for j in range(len(json_data["in-block"])):
                p = json_data["in-block"][j]
                if p[0] == m:
                    params.append([m, p[1], b])
                    del json_data["in-block"][j]
                    is_c_obsolete = True
                    break
        if not is_c_obsolete:
            new_constraints.append(c)
    json_m_cons[i] = new_constraints
json_data["in-block-succ"] = params

# Produce 'match-loc-domain' parameters
params = []
for i in range(len(json_m_cons)):
    new_constraints = []
    for c in json_m_cons[i]:
        l = parseSExpr(c)
        res = convert2MatchLocDomainParam(l)
        if res is not None:
            res.insert(0, i)
            params.append(res)
        else:
            new_constraints.append(c)
    json_m_cons[i] = new_constraints
json_data["match-loc-domain"] = params

# Produce 'fun-loc-domain' parameters
params = []
new_constraints = []
for c in json_data["fun-constraints"]:
    l = parseSExpr(c)
    res = convert2FunLocDomainParam(l)
    if res is not None:
        params.append(res)
    else:
        new_constraints.append(c)
# Updating the JSON data through an auxiliary, as done with the match
# constraint, doesn't work for the function constraints. Probably because it's
# just one level of lists and not a list of lists...
json_data["fun-constraints"] = new_constraints
json_data["fun-loc-domain"] = params

# Print JSON
print json.dumps(json_data)
