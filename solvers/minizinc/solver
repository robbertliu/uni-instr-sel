#!/bin/bash

#  Main authors:
#    Gabriel Hjort Blindell <ghb@kth.se>
#
#  Copyright (c) 2012-2016, Gabriel Hjort Blindell <ghb@kth.se>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions are met:
#  1. Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#  3. Neither the name of the copyright holder nor the names of its contributors
#     may be used to endorse or promote products derived from this software
#     without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
#  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



#==========
# SETTINGS
#==========

# Find the path to this directory (even through symbolic links)
# (from http://stackoverflow.com/a/246128/426092)
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # Resolve $SOURCE until the file is no longer a
                           # symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative
                                               # symlink, we need to resolve it
                                               # relative to the path where the
                                               # symlink file was located
done
THIS_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

JSON_SOLUTION_FILENAME="solution.json"
JSON_STATS_FILENAME="stats.json"
MINIZINC_PARAMS_FILENAME="params.mzn"
MINIZINC_FULL_MODEL_FILENAME="full-model.mzn"
MINIZINC_SOLUTION_FILENAME="full-model.szn"
MINIZINC_STATS_FILENAME="full-model.stats"
MINIZINC_ERROR_FILENAME="error.log"
MINIZINC_BASE_MODEL_FILEPATH="$THIS_DIR/base-model.mzn"

# These will be set after parsing command-line arguments
JSON_INPUT_FILEPATH=""
JSON_INPUT_FILENAME=""
JSON_SOLUTION_FILEPATH=""
JSON_STATS_FILEPATH=""
JSON_OUTPUT_FILEPATH=""
JSON_OUTPUT_DIR=""
TMP_DIR=""
MINIZINC_PARAMS_FILEPATH=""
MINIZINC_FULL_MODEL_FILEPATH=""
MINIZINC_SOLUTION_FILEPATH=""
MINIZINC_STATS_FILEPATH=""
MINIZINC_ERROR_FILEPATH=""
MINIZINC_SOLVER_BIN=""
MINIZINC_GLOBALS_DIR=""
MINIZINC_TIMELIMIT=""



#================
# HELP FUNCTIONS
#================

function echoerr {
    echo "$@" 1>&2
}

function echowarn {
    echoerr "$@"
}

function exe {
    echo "  Executing: $@"
    eval "$@"
}

function exitIfFailed {
    status=$?
    if [[ $status != 0 ]]; then
        if [ ! -z "$@" ]; then
            reportError "$@ (exit status $status)"
            echoerr
        else
            reportError "Terminated with exit status $status"
            echoerr
        fi
        exit 1
    fi
}

function ensureFileExists {
    if [ ! -f "$@" ]; then
        reportError "Required file \"$@\" does not exist"
        exit 1
    fi
}

function reportError {
    echoerr "*** ERROR: $@"
}

function reportWarning {
    echowarn "*** WARNING: $@"
}

function reportTask {
    msg=`echo "$@" | tr [a-z] [A-Z]`
    echo
    echo "* $msg..."
}

function reportNewEntity {
    echo "  Created: $@"
}

function reportUpdatedEntity {
    echo "  Updated: $@"
}

function reportLatestTimeFromStats {
    stats_filepath="$MINIZINC_STATS_FILEPATH"
    time=`tail -n 1 $stats_filepath | sed -n 's/^[^:]*: //p'`
    echo "  Took: $time"
}

function flattenModelFile {
    # It is assumed that the working directory is where the MZN file is
    fzn_filepath="${MINIZINC_FULL_MODEL_FILEPATH%.*}.fzn"
    reportTask "Flattening MiniZinc model file"
    stats_filepath="$MINIZINC_STATS_FILEPATH"
    echo -n "FLATTENING TIME: " > $stats_filepath
    command="`which time` -ap -o $stats_filepath --format %es"
    command="$command mzn2fzn -G $MINIZINC_GLOBALS_DIR"
    command="$command ${MINIZINC_FULL_MODEL_FILEPATH##*/}"
    exe "$command"
    exitIfFailed ""
    reportLatestTimeFromStats
    reportNewEntity "$fzn_filepath"
    reportNewEntity "${MINIZINC_FULL_MODEL_FILEPATH%.*}.ozn"
    reportUpdatedEntity "$stats_filepath"
}

function inflateSolutionFile {
    # It is assumed that the working directory is where the FZN and OZN files
    # are
    szn_filepath="${MINIZINC_FULL_MODEL_FILEPATH%.*}.szn"
    ozn_filepath="${MINIZINC_FULL_MODEL_FILEPATH%.*}.ozn"
    tmp_file="$MINIZINC_SOLUTION_FILEPATH.tmp"
    reportTask "Inflating MiniZinc solution file"
    exe "solns2out ${ozn_filepath##*/} < ${szn_filepath##*/} > $tmp_file"
    exitIfFailed ""
    exe "mv $tmp_file $MINIZINC_SOLUTION_FILEPATH"
    exitIfFailed ""
    reportUpdatedEntity "$MINIZINC_SOLUTION_FILEPATH"
}

function purgeIntermediateSolutions {
    tmp_file="$MINIZINC_SOLUTION_FILEPATH.tmp"
    reportTask "Purging intermediate solutions"
    exe "$THIS_DIR/purge-intermediate-solutions $MINIZINC_SOLUTION_FILEPATH" \
        " > $tmp_file"
    exitIfFailed ""
    exe "mv $tmp_file $MINIZINC_SOLUTION_FILEPATH"
    exitIfFailed ""
    reportUpdatedEntity "$MINIZINC_SOLUTION_FILEPATH"
}

function cleanupErrorFile {
    touch "$MINIZINC_ERROR_FILEPATH"
    mv "$MINIZINC_ERROR_FILEPATH" "$MINIZINC_ERROR_FILEPATH.tmp"
    cat "$MINIZINC_ERROR_FILEPATH.tmp" \
      | grep -v "Opturion CPX(tm)" \
      | grep -v "Academic license" \
      > "$MINIZINC_ERROR_FILEPATH"
}

function warnAboutPotentialErrors {
    error_word_count=`wc -w < $MINIZINC_ERROR_FILEPATH`
    if [[ $error_word_count > 0 ]]; then
        msg=`cat $MINIZINC_ERROR_FILEPATH`
        echowarn
        reportWarning "Potential problems were reported during solving:"
        echowarn "$msg"
        echowarn
    fi
}

function executeSolver {
    # It is assumed that the working directory is where the FZN and OZN files
    # are
    reportTask "Running solver"
    stats_filepath="$MINIZINC_STATS_FILEPATH"
    echo -n "SOLVING TIME: " >> $stats_filepath
    command="`which time` -ap -o $stats_filepath --format %es"
    if [[ $MINIZINC_TIMELIMIT > 0 ]]; then
        command="$command timeout ${MINIZINC_TIMELIMIT}s"
    fi
    command="$command $MINIZINC_SOLVER_BIN"
    if [[ $MINIZINC_TIMELIMIT > 0 ]]; then
        command="$command -a"
    fi
    command="$command ${MINIZINC_FULL_MODEL_FILENAME%.*}.fzn"
    command="$command > $MINIZINC_SOLUTION_FILEPATH"
    command="$command 2> $MINIZINC_ERROR_FILEPATH"
    exe "$command"
    solver_exit_status=$?
    if [[ $solver_exit_status == 124 ]]; then
        # Solver timed out
        solver_exit_status=0
    fi
    cleanupErrorFile
    error_msg=`cat $MINIZINC_ERROR_FILEPATH`
    $( exit $solver_exit_status ) # Restore $? to exit status of the solver
    exitIfFailed "$error_msg"
    warnAboutPotentialErrors
    reportLatestTimeFromStats
    reportNewEntity "$MINIZINC_SOLUTION_FILEPATH"
    reportUpdatedEntity "$stats_filepath"

    purgeIntermediateSolutions
}



#=============
# MAIN SCRIPT
#=============

# Parse arguments
while [[ $# > 1 ]]
do
    key="$1"

    case $key in
        -o|--output)
            JSON_OUTPUT_FILEPATH="$2"
            shift
        ;;
        -s|--solver)
            MINIZINC_SOLVER_BIN="$2"
            shift
        ;;
        -g|--globals)
            MINIZINC_GLOBALS_DIR="$2"
            shift
        ;;
        -t|--timelimit)
            MINIZINC_TIMELIMIT="$2"
            shift
        ;;
        -d|--compute-dom)
            COMPUTE_DOM_MATCHES=1
        ;;
        *)
            reportError "Unknown argument switch '$1'"
            exit 1
        ;;
    esac
    shift
done
if [[ $# == 1 ]]; then
    JSON_INPUT_FILEPATH="$1"
fi
if [ -z $MINIZINC_TIMELIMIT ]; then
    MINIZINC_TIMELIMIT=0
fi

# Check arguments
if [ -z "$JSON_INPUT_FILEPATH" ]; then
    reportError "No JSON input file provided (must be last argument)"
    exit 1
else
    ensureFileExists "$JSON_INPUT_FILEPATH"
fi
if [ -z "$JSON_OUTPUT_FILEPATH" ]; then
    reportError "No JSON output file provided (use -o or --output switch)"
    exit 1
fi
if [ -z "$MINIZINC_SOLVER_BIN" ]; then
    reportError "No solver specified (use -s or --solver switch)"
    exit 1
else
    if [[ "$MINIZINC_SOLVER_BIN" != fzn* ]]; then
        reportError "Only FZN solvers supported (name of executable must" \
                    "start with \"fzn\")"
        exit 1
    fi
fi
if [ -z "$MINIZINC_GLOBALS_DIR" ]; then
    reportError "No globals directory specified (use -g or --globals switch)"
    exit 1
fi

reportTask "Creating temporary directory"
TMP_DIR=`mktemp -d`
if [ ! -d "$TMP_DIR" ]; then
    reportError "Failed to create temporary directory"
fi
reportNewEntity "$TMP_DIR"

# Set filepath variables
JSON_INPUT_FILENAME="$(basename $JSON_INPUT_FILEPATH)"
JSON_INPUT_FILENAME="${JSON_INPUT_FILEPATH%.*}"
JSON_OUTPUT_DIR="$(dirname $JSON_OUTPUT_FILEPATH)"
JSON_EXT_FILEPATH="$JSON_OUTPUT_DIR/$JSON_INPUT_FILENAME.ext1.json"
JSON_EXT2_FILEPATH="$JSON_OUTPUT_DIR/$JSON_INPUT_FILENAME.ext2.json"
JSON_SOLUTION_FILEPATH="$TMP_DIR/$JSON_SOLUTION_FILENAME"
JSON_STATS_FILEPATH="$TMP_DIR/$JSON_STATS_FILENAME"
MINIZINC_PARAMS_FILEPATH="$TMP_DIR/$MINIZINC_PARAMS_FILENAME"
MINIZINC_FULL_MODEL_FILEPATH="$TMP_DIR/$MINIZINC_FULL_MODEL_FILENAME"
MINIZINC_SOLUTION_FILEPATH="$TMP_DIR/$MINIZINC_SOLUTION_FILENAME"
MINIZINC_STATS_FILEPATH="$TMP_DIR/$MINIZINC_STATS_FILENAME"
MINIZINC_ERROR_FILEPATH="$TMP_DIR/$MINIZINC_ERROR_FILENAME"

reportTask "Extending model instance with match sizes"
exe "$THIS_DIR/size-extender $JSON_INPUT_FILEPATH > $JSON_EXT_FILEPATH"
exitIfFailed
reportNewEntity $JSON_EXT_FILEPATH

reportTask "Converting constraints into parameter data"
exe "$THIS_DIR/constraints-converter $JSON_EXT_FILEPATH" \
    " > $JSON_EXT2_FILEPATH"
exitIfFailed
reportNewEntity $JSON_EXT2_FILEPATH

reportTask "Generating MiniZinc parameter file"
exe "$THIS_DIR/json2params $JSON_EXT2_FILEPATH > $MINIZINC_PARAMS_FILEPATH"
exitIfFailed
reportNewEntity $MINIZINC_PARAMS_FILEPATH

reportTask "Generating MiniZinc model file"
exe "cat $MINIZINC_BASE_MODEL_FILEPATH > $MINIZINC_FULL_MODEL_FILEPATH"
exitIfFailed ""
echo >> "$MINIZINC_FULL_MODEL_FILEPATH"
echo >> "$MINIZINC_FULL_MODEL_FILEPATH"
echo >> "$MINIZINC_FULL_MODEL_FILEPATH"
exe "cat $MINIZINC_PARAMS_FILEPATH >> $MINIZINC_FULL_MODEL_FILEPATH"
exitIfFailed ""
reportNewEntity "$MINIZINC_FULL_MODEL_FILEPATH"

MINIZINC_FULL_MODEL_SAVE_PATH="$JSON_OUTPUT_DIR/$JSON_INPUT_FILENAME.mzn"
reportTask "Saving MiniZinc model for later evaluation"
exe "cp $MINIZINC_FULL_MODEL_FILEPATH $MINIZINC_FULL_MODEL_SAVE_PATH"
exitIfFailed ""
reportNewEntity "$MINIZINC_FULL_MODEL_SAVE_PATH"

prev_dir=`pwd`
cd "$TMP_DIR"

# The following functions assume that the working directory is $TMP_DIR
flattenModelFile
executeSolver
inflateSolutionFile

cd "$prev_dir"

reportTask "Converting MiniZinc solution to JSON format"
exe "$THIS_DIR/solution2json $MINIZINC_SOLUTION_FILEPATH" \
    " > $JSON_SOLUTION_FILEPATH"
exitIfFailed ""
reportNewEntity "$JSON_SOLUTION_FILEPATH"

reportTask "Converting MiniZinc statistics to JSON format"
exe "$THIS_DIR/stats2json $MINIZINC_STATS_FILEPATH > $JSON_STATS_FILEPATH"
exitIfFailed ""
reportNewEntity "$JSON_STATS_FILEPATH"

reportTask "Merging JSON files"
exe "$THIS_DIR/merge-jsons $JSON_SOLUTION_FILEPATH $JSON_STATS_FILEPATH" \
    " > $JSON_OUTPUT_FILEPATH"
exitIfFailed ""
reportNewEntity "$JSON_OUTPUT_FILEPATH"

echo
