#!/usr/bin/python

# Copyright (c) 2013-2015, Gabriel Hjort Blindell <ghb@kth.se>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.



#=========
# IMPORTS
#=========

import json
import os.path
import sys



#================
# HELP FUNCTIONS
#================

def error(msg):
    sys.stderr.write("ERROR: " + msg + "\n")
    sys.exit(1)

# A match m1 is dominated if there exists some other match m2 where:
#    - neither match occurs in the parameters "same-loc", "in-block", and
#      "in-block-succ" (TODO: relax?),
#    - the tuple <latency of m2, index of m2> is lexicographically smaller than
#      the tuple <latency of m1, index of m1>,
#    - both matches cover exactly the same operations,
#    - both matches define exactly the same data,
#    - both matches use exactly the same data,
#    - both matches have the same entry block,
#    - both matches span across the same blocks,
#    - both matches apply the def-dom-use constraint,
#    - if m2 defines any constraints in the parameter "loc-domain", then m1
#      defines constraints that are at least as strong,
#      and
#    - both matches have exactly the same auxiliary constraints (TODO: relax?).
def isMatchDominated(json, m1):
    def IsLocDomainAtLeastAsStrong(json, m2):
        loc_domains = json["loc-domain"]
        R = range(len(loc_domains))
        for i in [ i for i in R if loc_domains[i][0] == m2]:
            # Find constraint in m1 that is at least as strong
            found = False
            for j in [ j for j in R if loc_domains[j][0] == m2
                                    and
                                    loc_domains[i][1] == loc_domains[j][1]
                     ]:
                if set(range(loc_domains[j][2], loc_domains[j][3])).issubset(
                     set(range(loc_domains[i][2], loc_domains[i][3]))
                   ):
                    found = True
                    break

            # No such constraint found
            if not found:
                return False

        # All checks have passed
        return True



    excl_matches = ( set([ int(t[0]) for t in json["same-loc"] ])
                     |
                     set([ int(t[0]) for t in json["in-block"] ])
                     |
                     set([ int(t[0]) for t in json["in-block-succ"] ])
                   )

    # Check if m1 can be dominated at all
    if m1 in excl_matches:
        return False

    # Check all eligable matches
    for m2 in [ m for m in range(json["num-matches"])
                if m != m1 and m not in excl_matches
              ]:
        if ( ( json["match-latencies"][m2] < json["match-latencies"][m1]
               or
               ( json["match-latencies"][m2] == json["match-latencies"][m1]
                 and
                 m2 < m1
               )
             )
             and
             ( set(json["match-operations-covered"][m2])
               ==
               set(json["match-operations-covered"][m1])
             )
             and
             ( set(json["match-data-defined"][m2])
               ==
               set(json["match-data-defined"][m1])
             )
             and
             ( set(json["match-data-used"][m2])
               ==
               set(json["match-data-used"][m1])
             )
             and
             json["match-entry-blocks"][m2] == json["match-entry-blocks"][m1]
             and
             ( set(json["match-spanned-blocks"][m2])
               ==
               set(json["match-spanned-blocks"][m1])
             )
             and
             ( json["match-adduc-settings"][m2]
               ==
               json["match-adduc-settings"][m1]
             )
             and
             IsLocDomainAtLeastAsStrong(json, m2)
             and
             json["match-constraints"][m2] == json["match-constraints"][m1]
           ):
            # Found dominating match
            return True

    # No dominating match found
    return False



#=============
# MAIN SCRIPT
#=============

# Check arguments
if len(sys.argv) < 2:
    sys.stderr.write("No JSON file given\n")
    sys.exit(1)
if len(sys.argv) > 2:
    sys.stderr.write("Too many arguments\n")
    sys.exit(1)
json_file = sys.argv[1]
if not os.path.isfile(json_file):
    error("JSON file '" + json_file +"' not found")

# Read JSON file
json_data = []
with open(json_file, 'r') as file:
    json_data = json.load(file)

# Computed dominated-matches parameter
json_data["dominated-matches"] = [ m
                                   for m in range(json_data["num-matches"])
                                   if isMatchDominated(json_data, m)
                                 ]

# Print JSON
print json.dumps(json_data)
