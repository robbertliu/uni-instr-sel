{-|
Copyright   :  Copyright (c) 2012-2017, Gabriel Hjort Blindell <ghb@kth.se>
License     :  BSD3 (see the LICENSE file)
Maintainer  :  ghb@kth.se
-}
{-
Main authors:
  Gabriel Hjort Blindell <ghb@kth.se>

-}

module Language.InstrSel.TargetMachines.Generators.HaskellCodeGenerator where

import Language.InstrSel.TargetMachines.Base
  ( TargetMachine (tmID)
  , fromTargetMachineID
  , toSafeTargetMachineID
  )
import qualified Language.InstrSel.Utils.ByteString as BS
import Language.InstrSel.Utils.ByteStringBuilder

import Language.Haskell.Exts



-------------
-- Functions
-------------

-- | Takes a 'TargetMachine' and generates corresponding Haskell source code.
-- The source code is then wrapped inside a module with name equal to its
-- 'Language.InstrSel.TargetMachines.IDs.TargetMachineID'. The source code is
-- also paired with a 'FilePath' with the name of the generated module. If the
-- target machine contains many instructions, then it will be split into
-- multiple submodules.
generateModule
  :: String
     -- ^ Parent module to wherein the generated module(s) will reside.
  -> Bool
     -- ^ Whether to pretty-print the code of the module.
  -> TargetMachine
  -> [(FilePath, BS.ByteString)]
generateModule mparent pretty_print tm =
  let module_name = fromTargetMachineID $
                    toSafeTargetMachineID $
                    fromTargetMachineID (tmID tm)
  in [generateTopModule mparent module_name pretty_print tm]

-- | Generates Haskell code for top-level module.
generateTopModule
  :: String
     -- ^ Parent module to wherein the generated module(s) will reside.
  -> String
     -- ^ Name of the top module.
  -> Bool
     -- ^ Whether to pretty-print the code of the module.
  -> TargetMachine
  -> (FilePath, BS.ByteString)
generateTopModule mparent module_name pretty_print tm =
  let renameFuncs str = BS.replace (BS.pack "mkGraph") (BS.pack "I.mkGraph") str
      module_path = mparent ++ "." ++ module_name
      file = module_name ++ ".hs"
      header_src =
        stringUtf8 "module " <> stringUtf8 module_path <>
        stringUtf8 "\n\
                   \  ( theTM )\n\
                   \where\n\n\
                   \import Language.InstrSel.Constraints\n\
                   \import Language.InstrSel.DataTypes\n\
                   \import Language.InstrSel.Graphs\n\
                   \import Language.InstrSel.Functions.IDs\n\
                   \import qualified Data.Graph.Inductive as I\n\
                   \import Language.InstrSel.OpStructures\n\
                   \import Language.InstrSel.OpTypes\n\
                   \import Language.InstrSel.TargetMachines\n\
                   \import Language.InstrSel.Utils\n\
                   \import Prelude\n\
                   \  hiding\n\
                   \  ( LT, GT )\n\
                   \import Data.Map\n\
                   \  ( fromList )\n\n"
      tm_func_src =
        stringUtf8 "theTM :: TargetMachine\n\
                   \theTM = " <>
        lazyByteString (renameFuncs $ BS.pack $ show tm)
      haskell_code = toLazyByteString $ header_src <> tm_func_src
      module_code =
        toLazyByteString $
        lazyByteString (generateBoilerPlateCode module_path) <>
        lazyByteString ( if pretty_print
                         then prettyPrintModuleCode haskell_code
                         else haskell_code
                       )
  in (file, module_code)

-- | Generates boiler platep code for a given module.
generateBoilerPlateCode
  :: String
     -- ^ The module path.
  -> BS.ByteString
generateBoilerPlateCode mpath =
  toLazyByteString $
  stringUtf8 (replicate 80 '-') <>
  stringUtf8 "\n\
             \-- |\n\
             \-- Module      : " <>
  stringUtf8 mpath <>
  stringUtf8 "\n\
             \-- Stability   : experimental\n\
             \-- Portability : portable\n\
             \--\n\
             \-- THIS MODULE HAS BEEN AUTOGENERATED!\n\
             \--\n" <>
  stringUtf8 (replicate 80 '-') <>
  stringUtf8 "\n\n"

-- | Pretty-prints given Haskell code for a module.
prettyPrintModuleCode :: BS.ByteString -> BS.ByteString
prettyPrintModuleCode code =
  let parse_res = parseFileContents $ BS.unpack code
      prettify m = prettyPrintStyleMode (style { lineLength = 80 })
                                        defaultMode m
  in case parse_res
     of (ParseOk m) -> BS.pack $ prettify m
        (ParseFailed line msg) -> error $ "prettyPrintModule: " ++
                                          "parsing failed at " ++
                                          show line ++ ": " ++ msg
