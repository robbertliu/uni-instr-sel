{-|
Copyright   :  Copyright (c) 2012-2017, Gabriel Hjort Blindell <ghb@kth.se>
License     :  BSD3 (see the LICENSE file)
Maintainer  :  ghb@kth.se
-}
{-
Main authors:
  Gabriel Hjort Blindell <ghb@kth.se>

-}

module Language.InstrSel.TargetMachines.Generators.HaskellCodeGenerator where

import Language.InstrSel.TargetMachines.Base
  ( TargetMachine (tmID)
  , fromTargetMachineID
  )
import qualified Language.InstrSel.Utils.ByteString as BS
import Language.InstrSel.Utils.ByteStringBuilder

import Language.Haskell.Exts



-------------
-- Functions
-------------

-- | Takes a 'TargetMachine' and generates corresponding Haskell source code.
-- The source code is then wrapped inside a module with name equal to the
-- 'Language.InstrSel.TargetMachines.IDs.TargetMachineID'.
generateModule :: TargetMachine -> BS.ByteString
generateModule tm =
  let renameFuncs str = BS.replace (BS.pack "mkGraph") (BS.pack "I.mkGraph") str
      tm_id = fromTargetMachineID (tmID tm)
      boiler_src =
        stringUtf8 "-----------------------------------------------------------\
                   \---------------------\n\
                   \-- |\n\
                   \-- Module      : UniIS.Targets." <>
        stringUtf8 tm_id <>
        stringUtf8 "\n\
                   \-- Stability   : experimental\n\
                   \-- Portability : portable\n\
                   \--\n\
                   \-- THIS MODULE HAS BEEN AUTOGENERATED!\n\
                   \--\n\
                   \-----------------------------------------------------------\
                   \---------------------\n\n"
      header_src =
        stringUtf8 "module UniIS.Targets." <>
        stringUtf8 tm_id <>
        stringUtf8 "\n\
                   \  ( theTM )\n\
                   \where\n\n\
                   \import Language.InstrSel.Constraints\n\
                   \import Language.InstrSel.DataTypes\n\
                   \import Language.InstrSel.Graphs\n\
                   \import Language.InstrSel.Functions.IDs\n\
                   \import qualified Data.Graph.Inductive as I\n\
                   \import Language.InstrSel.OpStructures\n\
                   \import Language.InstrSel.OpTypes\n\
                   \import Language.InstrSel.TargetMachines\n\
                   \import Language.InstrSel.Utils\n\
                   \import Prelude \n\
                   \  hiding\n\
                   \  ( LT, GT )\n\
                   \import Data.Map\n\
                   \  ( fromList )\n\n"
      tm_func_src =
        stringUtf8 "theTM :: TargetMachine\n\
                   \theTM = " <>
        lazyByteString (renameFuncs $ BS.pack $ show tm)
      haskell_code = header_src <> tm_func_src
      res = parseFileContents $ BS.unpack $ toLazyByteString haskell_code
      prettify m = prettyPrintStyleMode (style { lineLength = 80 })
                                        defaultMode m
  in case res
     of (ParseOk m) -> toLazyByteString $
                       boiler_src <>
                       (stringUtf8 $ prettify m)
        (ParseFailed line msg) -> error $ "generateModule: parsing failed at "
                                         ++ show line ++ ": " ++ msg
