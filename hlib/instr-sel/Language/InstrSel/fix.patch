diff --git a/src/instr-sel/hlib/instr-sel/Language/InstrSel/ConstraintModels/ModelHandler.hs b/src/instr-sel/hlib/instr-sel/Language/InstrSel/ConstraintModels/ModelHandler.hs
index ca14c75..1c8837a 100644
--- a/src/instr-sel/hlib/instr-sel/Language/InstrSel/ConstraintModels/ModelHandler.hs
+++ b/src/instr-sel/hlib/instr-sel/Language/InstrSel/ConstraintModels/ModelHandler.hs
@@ -28,6 +28,7 @@ import Language.InstrSel.Graphs.Graphalyze
   , cyclesIn'
   )
 import Language.InstrSel.OpStructures
+import Language.InstrSel.PrettyShow
 import Language.InstrSel.Functions
   ( Function (..)
   , fromFunctionName
@@ -77,7 +78,7 @@ mkHighLevelModel function target matches =
       machine_params = mkHLMachineParams target
       match_params = mkHLMatchParamsList target matches
       ill_m_combs = mkIllegalMatchCombs function target matches
-      interch_data = mkInterchangeableData match_params
+      interch_data = mkInterchangeableData function match_params
   in HighLevelModel { hlFunctionParams = f_params
                     , hlMachineParams = machine_params
                     , hlMatchParams = match_params
@@ -276,7 +277,7 @@ enableCopyingForMultUseInputsInPattern instr match =
                            then getTargetNode g0 $ head $ es'
                            else error $
                                 "enableCopyingForMultUseInputsInPattern: " ++
-                                "pattern node " ++ show cp_n ++ " has no " ++
+                                "pattern node " ++ pShow cp_n ++ " has no " ++
                                 "outgoing data-flow edges"
             old_input_id = getNodeID old_input
             new_input_id = getNodeID new_input
@@ -921,9 +922,20 @@ mkIllegalMatchCombs function target matches =
 --
 -- This first gathers all sets of data that can be used, removing those that
 -- contain a datum that appears as the only element in some set.
-mkInterchangeableData :: [HighLevelMatchParams] -> [[NodeID]]
-mkInterchangeableData params =
-  let all_alt_uses =
+mkInterchangeableData :: Function -> [HighLevelMatchParams] -> [[NodeID]]
+mkInterchangeableData function params =
+  let hasDefEdge nid =
+        let g = osGraph $ functionOS function
+            n = let ns = findNodesWithNodeID g nid
+                in if length ns == 1
+                   then head ns
+                   else if length ns == 0
+                        then error $ "mkInterchangeableData: no node with " ++
+                                     "ID " ++ pShow nid
+                        else error $ "mkInterchangeableData: multiple nodes " ++
+                                     "with ID " ++ pShow nid
+        in length (getDefOutEdges g n) > 0
+      all_alt_uses =
         concatMap ( \m ->
                     let use_ops = hlMatchOperandsUsed m
                     in map (\p -> fromJust $ lookup p (hlOperandNodeMaps m)) $
@@ -937,8 +949,10 @@ mkInterchangeableData params =
                        concat $
                        filter (\l -> length l == 1) $
                        all_alt_uses
-      interch_data = nub $
+      interch_data = filter (\l -> length l > 1) $
+                     nub $
                      map sort $
+                     filter (not . any hasDefEdge) $
                      filter (not . any (\n -> M.member n unary_uses_set)) $
                      all_alt_uses
   in interch_data
